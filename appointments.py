import time
import traceback
import argparse
from datetime import date, datetime, timedelta
from pprint import pprint

import requests
import pytz
from tweet import TwitterHandler
from colorama import Fore, Back, Style

GEOCODES = {
    # lat, lng
    'Bay Area': [
        (37.77493,-122.419415), # San Francisco
        (37.871523,-122.273042), # Berkley
        (37.804351,-122.271164), # Oakland
        (37.387474,-122.057543), # Silicon Valley
    ],
    'Los Angeles': [
        (33.96168,-118.353131), # Inglewood
        (34.238125,-118.530123), # Northridge
        (34.425331,-118.597219), # Sixflags
        (33.976124,-117.905339), # Rowland heights
        (33.980601,-117.375494), # Riverside
    ],
    'Sacremento': [
        (38.581572,-121.4944), # Sacremento
        (38.677959,-121.176058), # Folsom
    ],
    'San Diego': [
        (32.715738,-117.161084), # San Diego
    ],
    # 'Marin': [
    #     (38.083403,-122.763304), # Marin County
    #     (37.973535,-122.531087), # San Rafael
    # ]
    'Ventura/Oxnard': [
        (34.280492,-119.29452), # Ventura County
        (34.197505,-119.177052), # Oxnard
    ]
}

STATE = {}

for key in GEOCODES.keys():
    STATE[key] = {'current': -1, 'max': -1, 'start': None, 'end': None}

def get_locations(location_group):
    locations = {}

    # Generated by burp
    url = "https://api.myturn.ca.gov:443/public/locations/search"
    headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "64052e12-a43a-41c2-a104-8290aaf43eb4", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}

    for lat, lng in GEOCODES[location_group]:
        payload = {"fromDate": "2021-02-20", "location": {"lat": lat, "lng": lng}, "locationQuery": {"includePools": ["default"]}, "url": "https://myturn.ca.gov/location-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiLCJhM3F0MDAwMDAwMDFBZE1BQVUiLCJhM3F0MDAwMDAwMDFBZ1VBQVUiLCJhM3F0MDAwMDAwMDFBZ1ZBQVUiXQ=="}

        res =  requests.post(url, headers=headers, json=payload)
        res.raise_for_status()

        res_json = res.json()

        if not res_json['locations']:
            continue
    
        for loc in res_json['locations']:
            id = loc['extId']
            name = loc['name']
            if id in locations:
                continue

            locations[id] = { 'id': id, 'name': name }

    return locations

def get_appt_days(id, start, end):

    # Generated by burp
    burp0_url = f"https://api.myturn.ca.gov:443/public/locations/{id}/availability"
    burp0_headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "3c3d1dda-7006-4d18-81e7-f7595ef1a55d", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}
    burp0_json={"doseNumber": 1, "endDate": str(end), "startDate": str(start), "url": "https://myturn.ca.gov/appointment-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiXQ=="}
    resp = requests.post(burp0_url, headers=burp0_headers, json=burp0_json)
    resp.raise_for_status()
    resp_json = resp.json()

    appts = [apt['date'] for apt in resp_json['availability'] if apt['available']]
    return appts

def get_slots(id, day):
    burp0_url = f"https://api.myturn.ca.gov:443/public/locations/{id}/date/{day}/slots"
    burp0_headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "3c3d1dda-7006-4d18-81e7-f7595ef1a55d", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}
    burp0_json={"url": "https://myturn.ca.gov/appointment-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiXQ=="}
    resp = requests.post(burp0_url, headers=burp0_headers, json=burp0_json)
    resp.raise_for_status()
    resp_json = resp.json()

    slots = [datetime.strptime(slot['localStartTime'], '%H:%M:%S').strftime('%I:%M %p') for slot in resp_json['slotsWithAvailability']]
    return slots

def get_location_appts(locations, start, end):
    appts = {}
    for loc in locations.values():
        loc_appt_days = get_appt_days(loc['id'], start, end)
        slots = {}
        for day in loc_appt_days:
            slots[day] = get_slots(loc['id'], day)
            appts[loc['id']] = slots

    return appts

def format_appointments(locations, appointments):
    total = 0
    for id, appts in appointments.items():
        name = locations[id]['name']
        print(f'Appointments for {name}:')
        print(Fore.CYAN)
        pprint(appts)

        for slots in appts.values():
            total += len(slots)
        print('')
        print(Style.RESET_ALL)

def get_total_appointments(appointments):
    total = 0
    start = None
    end = None
    for appts in appointments.values():
        # Figure out earliest and latest appointment days
        for d, slots in appts.items():
            if not slots:
                continue

            total += len(slots)
            day = datetime.strptime(d, '%Y-%m-%d')
            if not start:
                start = day
            else:
                start = min([start, day])

            if not end:
                end = day
            else:
                end = max([end, day])

    return total, start, end

def get_group_appointments(location_group, start, end):
    print('*' * 100)
    print(f'{Fore.YELLOW}Getting {location_group} availability{Style.RESET_ALL}')
    print('*' * 100)

    locations = get_locations(location_group)
    
    appts = get_location_appts(locations, start, end)
    total, start, end = get_total_appointments(appts)
    return locations, appts, total, start, end

def print_appointments(location_group, locations, appts, total, start, end, print_slots=False):
    if total == 0:
        color = Fore.RED
    elif total <= 10:
        color = Fore.YELLOW
    else:
        color = Fore.GREEN

    print(f'{color} {location_group} has {total} available appointments between {start} - {end}{Style.RESET_ALL}')

    if total and print_slots:
        print('-----Listing slots:')
        format_appointments(locations, appts)

    print(Style.RESET_ALL)

def get_timestamp():
    tz = pytz.timezone('US/Pacific')
    t = datetime.now(tz).strftime("%I:%M %p")
    return f'({t})'

def get_tweet(location_group, total, start, end):
    prev = STATE[location_group]['current'] 
    prev_max = STATE[location_group]['max'] 
    prev_start = STATE[location_group]['start'] 
    prev_end = STATE[location_group]['end'] 
    STATE[location_group]['current'] = total
    STATE[location_group]['start'] = start
    STATE[location_group]['end'] = end

    # Reset max if previous appointments are out
    if total == 0:
        STATE[location_group]['max'] = 0
    else:
        STATE[location_group]['max'] = max([prev_max, total])

    print('-----stats:')
    pprint(STATE[location_group])


    # Never had appointments
    if (prev <= 0 and total > 0) or (total > 0 and (prev_start != start or prev_end != end)) :
        if start == end:
            tweet = f'{location_group} has {total} appointments on {start} ðŸ™Œ\nBook one now at myturn.ca.gov!'
        else:
            tweet = f'{location_group} has {total} appointments between {start} - {end} ðŸ™Œ\nBook one now at myturn.ca.gov!'
    # Was >0 appointments, but now no appointments
    elif (prev > 0 and total == 0) or prev == -1:
        tweet = f'{location_group} has no more available appointments ðŸ˜”\nNo worries, I\'ll keep checking for you ðŸ¤–'
    # Number of appointments greater than max
    elif total > prev_max and prev_max > 0:
        diff = total - prev_max
        if start == end:
            tweet = f'{location_group} added {diff} appointments ðŸ¤©\nThere are now {total} appointments on {start}\nBook one at myturn.ca.gov!'
        else:
            tweet = f'{location_group} added {diff} appointments ðŸ¤©\nThere are now {total} appointments between {start} - {end}\nBook one at myturn.ca.gov!'
    else:
        tweet = None

    # Add a seasrchable hashtag
    if tweet:
        location_tag = f'#{location_group.replace(" ", "")}Appts'
        timestamp = get_timestamp()
        return f'{timestamp} {tweet} {location_tag}'
    else:
        return None


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--no-tweet', 
        help='Dont send out tweets',
        action='store_true',
        required=False,
    )

    parser.add_argument('--no-error', 
        help='Dont send error message DMs',
        action='store_true',
        required=False,
    )

    args = parser.parse_args()

    twitter_handler = TwitterHandler()

    while(True):
        for group in GEOCODES.keys():
            try:
                search_start = date.today()
                search_end = search_start + timedelta(days=8)
                locations, appts, total, appt_start, appt_end = get_group_appointments(group, search_start, search_end)

                if total:
                    start = appt_start.strftime('%m-%d-%Y')
                    end = appt_end.strftime('%m-%d-%Y')
                else:
                    start = search_start.strftime('%m-%d-%Y')
                    end = search_end.strftime('%m-%d-%Y')

                print_appointments(group, locations, appts, total, start, end, print_slots=True)
                print('Generating tweet:')
                print('-'* 10)
                tweet = get_tweet(group, total, start, end)
                if tweet:
                    print(Fore.LIGHTMAGENTA_EX + tweet.replace('\n', '\n' + Fore.LIGHTMAGENTA_EX ) + Style.RESET_ALL)
                    if not args.no_tweet:
                        twitter_handler.tweet(tweet)
                else:
                    print('<last tweet is still accurate. not tweeting>')
                print('-'* 10)
            except Exception:
                error_str = traceback.format_exc()
                if not args.no_error:
                    twitter_handler.dm(error_str)

                print(Fore.RED + error_str + Style.RESET_ALL)

        sleep = 60
        print(f'Sleeping {sleep} seconds...')
        time.sleep(60)

main()
