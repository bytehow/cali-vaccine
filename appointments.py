import time
import traceback
import argparse
from datetime import date, datetime, timedelta
from pprint import pprint

import requests
import pytz
from tweet import TwitterHandler
from colorama import Fore, Back, Style

GEOCODES = {
    # lat, lng
    'Bay Area': [
        (37.77493,-122.419415), # San Francisco
        (37.871523,-122.273042), # Berkley
        (37.804351,-122.271164), # Oakland
        (37.387474,-122.057543), # Silicon Valley
    ],
    'Los Angeles': [
        (33.96168,-118.353131), # Inglewood
        (34.238125,-118.530123), # Northridge
        (34.425331,-118.597219), # Sixflags
        (33.976124,-117.905339), # Rowland heights
        (33.980601,-117.375494), # Riverside
    ],
    # 'Sacramento': [
    #     (38.581572,-121.4944), # Sacremento
    #     (38.677959,-121.176058), # Folsom
    # ],
    'San Diego': [
        (32.700958,-117.126016), # Central Region Immunization Clinic
        (32.672315,-117.10377), # Martin Luther King Community Center- Janssen
        (32.710125,-117.084695), # Tubman-Chavez Community Center
        (32.755407,-117.101196), # Copley-Price YMCA
        (32.740031,-117.029802), # Lemon Grove Community Center
        (32.606372,-117.085752), # South Region Live Well Center at Chula Vista
        (32.576672,-117.121752), # Mar Vista High School
        (32.57815,-117.05707), # Border View YMCA - Janssen
        (32.555746,-117.05417), # San Ysidro Southwestern College
        (32.798785,-116.960557), # East Public Health Center
        (32.973742,-117.260998), # North Coastal â€“ Scripps Del Mar Fairgrounds Park Super Station
        (33.12486,-117.075823), # Palomar Medical Center Downtown Escondido
        (33.131983,-117.157541), # San Marcos Vaccine Super Station at Cal State University San Marcos (CSUSM), Sports Center
        (33.2081,-117.245749), # Linda Rhoades Recreation Center
        (33.211189,-117.311218), # North Coastal Live Well Center
    ],
    # 'Marin': [
    #     (38.083403,-122.763304), # Marin County
    #     (37.973535,-122.531087), # San Rafael
    # ],
    # 'Ventura/Oxnard': [
    #     (34.280492,-119.29452), # Ventura County
    #     (34.197505,-119.177052), # Oxnard
    # ],
    # 'Merced': [
    #     (37.200979,-120.712002 ), # Merced County
    # ],
    # 'Orange County': [
    #     (33.787914,-117.853101), # Orange County
    #     (33.836593,-117.914301), # Anaheim
    #     (33.554798,-117.735208), # Soka University
    # ]
}

STATE = {}
PROXIES = {
    'http': 'http://localhost:24000',
    'https': 'http://localhost:24000',
}

PROXY_HOST='localhost'

for key in GEOCODES.keys():
    STATE[key] = {'current': -1, 'max': -1, 'start': None, 'end': None}

def make_proxied_request(method, url, always_proxy=False, **kwargs):
    if always_proxy:
        return requests.request(method, url, proxies=PROXIES,  **kwargs)

    resp = requests.request(method, url, **kwargs)
    # Try with proxy
    if (resp.status_code == 403):
        print('Got 403. Using proxy')
        resp = requests.request(method, url, proxies=PROXIES, **kwargs)

    return resp

def get_locations(location_group):
    locations = {}

    # Generated by burp
    url = "https://api.myturn.ca.gov:443/public/locations/search"
    headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "64052e12-a43a-41c2-a104-8290aaf43eb4", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}

    for lat, lng in GEOCODES[location_group]:
        today = str(date.today())
        payload={"doseNumber": 1, "fromDate": today, "location": {"lat": lat, "lng": lng}, "locationQuery": {"includePools": ["default"]}, "url": "https://myturn.ca.gov/location-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiLCJhM3F0MDAwMDAwMDFBZE1BQVUiLCJhM3F0MDAwMDAwMDFBZ1VBQVUiLCJhM3F0MDAwMDAwMDFBZ1ZBQVUiXQ=="}

        res = make_proxied_request('POST', url, headers=headers, json=payload)
        res.raise_for_status()
        res_json = res.json()

        if not res_json['locations']:
            continue

        for loc in res_json['locations']:
            if loc['type'] != 'OnlineBooking':
                continue

            id = loc['extId']
            name = loc['name']
            address = loc['displayAddress']
            if id in locations:
                continue

            locations[id] = { 'id': id, 'name': name, 'address': address }

    return locations

def get_appt_days(id, start, end, dose=1):

    # Generated by burp
    burp0_url = f"https://api.myturn.ca.gov:443/public/locations/{id}/availability"
    burp0_headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "3c3d1dda-7006-4d18-81e7-f7595ef1a55d", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}
    burp0_json={"doseNumber": dose, "endDate": str(end), "startDate": str(start), "url": "https://myturn.ca.gov/appointment-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiXQ=="}
    resp = make_proxied_request('POST', burp0_url, headers=burp0_headers, json=burp0_json)
    resp.raise_for_status()
    resp_json = resp.json()

    appts = [apt['date'] for apt in resp_json['availability'] if apt['available']]
    return appts

def get_slots(id, day):
    burp0_url = f"https://api.myturn.ca.gov:443/public/locations/{id}/date/{day}/slots"
    burp0_headers = {"Connection": "close", "sec-ch-ua": "\";Not A Brand\";v=\"99\", \"Chromium\";v=\"88\"", "Accept": "application/json, text/plain, */*", "X-Correlation-Id": "3c3d1dda-7006-4d18-81e7-f7595ef1a55d", "sec-ch-ua-mobile": "?0", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36", "Content-Type": "application/json;charset=UTF-8", "Origin": "https://myturn.ca.gov", "Sec-Fetch-Site": "same-site", "Sec-Fetch-Mode": "cors", "Sec-Fetch-Dest": "empty", "Referer": "https://myturn.ca.gov/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9"}
    burp0_json={"url": "https://myturn.ca.gov/appointment-select", "vaccineData": "WyJhM3F0MDAwMDAwMDFBZExBQVUiXQ=="}
    resp = make_proxied_request('POST', burp0_url, headers=burp0_headers, json=burp0_json)
    resp.raise_for_status()
    resp_json = resp.json()

    slots = [datetime.strptime(slot['localStartTime'], '%H:%M:%S').strftime('%I:%M %p') for slot in resp_json['slotsWithAvailability']]
    return slots

def get_location_appts(locations, start, end):
    today = str(date.today())
    appts = {}
    for loc in locations.values():
        # Get first appointments
        first_appt_days = get_appt_days(loc['id'], start, end, dose=1)
        first_slots = {}

        # Get appointment times
        for first_dose_day_str in first_appt_days:
            # Appointments have to be in the future, so we need to filter out slots that are already passed
            first_dose_slots = get_slots(loc['id'], first_dose_day_str)
            if first_dose_day_str == today:
                filtered_slots = []
                for s in first_dose_slots:
                    slot = datetime.strptime(first_dose_day_str + s, '%Y-%m-%d%I:%M %p')
                    if slot > datetime.now():
                        filtered_slots.append(slot.strftime('%I:%M %p'))

                first_dose_slots = filtered_slots

            if not first_dose_slots:
                continue

            # Is there a second dose to match this one?
            second_dose_day = datetime.strptime(first_dose_day_str, '%Y-%m-%d') + timedelta(days=21)
            second_dose_day_str = second_dose_day.strftime('%Y-%m-%d')
            second_doses_available = get_appt_days(loc['id'], second_dose_day_str, second_dose_day_str, dose=2)

            if not second_doses_available:
                continue

            # An appointment doesn't count if you can't get a second shot
            second_dose_slots = get_slots(loc['id'], second_dose_day_str)
            diff = len(first_dose_slots) - len(second_dose_slots)
            if diff > 0:
                first_slots[first_dose_day_str] = sorted(first_dose_slots)[:-diff]
            else:
                first_slots[first_dose_day_str] = sorted(first_dose_slots)

            appts[loc['id']] = first_slots

    return appts

def format_appointments(locations, appointments):
    for id, appts in appointments.items():
        name = locations[id]['name']
        print(f'Appointments for {name} ({id}):')
        print(Fore.CYAN)
        pprint(appts)

        print('')
        print(Style.RESET_ALL)

def get_total_appointments(appointments):
    total = 0
    start = None
    end = None
    for appts in appointments.values():
        # Figure out earliest and latest appointment days
        for d, slots in appts.items():
            if not slots:
                continue

            total += len(slots)
            day = datetime.strptime(d, '%Y-%m-%d')
            if not start:
                start = day
            else:
                start = min([start, day])

            if not end:
                end = day
            else:
                end = max([end, day])

    return total, start, end

def get_group_appointments(location_group, start, end):
    print('*' * 100)
    print(f'{Fore.YELLOW}Getting {location_group} availability{Style.RESET_ALL}')
    print('*' * 100)

    locations = get_locations(location_group)
    
    appts = get_location_appts(locations, start, end)
    total, start, end = get_total_appointments(appts)
    return locations, appts, total, start, end

def print_appointments(location_group, locations, appts, total, start, end, print_slots=False):
    if total == 0:
        color = Fore.RED
    elif total <= 10:
        color = Fore.YELLOW
    else:
        color = Fore.GREEN

    print(f'{color} {location_group} has {total} available appointments between {start} - {end}{Style.RESET_ALL}')

    if total and print_slots:
        print('-----Listing slots:')
        format_appointments(locations, appts)

    print(Style.RESET_ALL)

def get_timestamp():
    tz = pytz.timezone('US/Pacific')
    t = datetime.now(tz).strftime("%I:%M %p")
    return f'({t})'

def get_summary_tweet(location_group, total, start, end):
    prev = STATE[location_group]['current'] 
    prev_max = STATE[location_group]['max'] 
    prev_start = STATE[location_group]['start'] 
    prev_end = STATE[location_group]['end'] 
    STATE[location_group]['current'] = total
    STATE[location_group]['start'] = start
    STATE[location_group]['end'] = end

    # Reset max if previous appointments are out
    if total == 0:
        STATE[location_group]['max'] = 0
    else:
        STATE[location_group]['max'] = max([prev_max, total])

    print('-----stats:')
    pprint(STATE[location_group])


    # Never had appointments
    if (prev <= 0 and total > 0) or (total > 0 and (prev_start != start or prev_end != end)) :
        if start == end:
            tweet = f'{location_group} has {total} appointments on {start} ðŸ™Œ\nBook one now at myturn.ca.gov!'
        else:
            tweet = f'{location_group} has {total} appointments between {start} - {end} ðŸ™Œ\nBook one now at myturn.ca.gov!'
    elif total > prev_max and prev_max > 0:
        diff = total - prev_max
        if start == end:
            tweet = f'{location_group} added {diff} appointments ðŸ¤©\nThere are now {total} appointments on {start}\nBook one at myturn.ca.gov!'
        else:
            tweet = f'{location_group} added {diff} appointments ðŸ¤©\nThere are now {total} appointments between {start} - {end}\nBook one at myturn.ca.gov!'
    else:
        tweet = None

    # Add a seasrchable hashtag
    if tweet:
        location_tag = f'#{location_group.replace(" ", "")}Appts'
        timestamp = get_timestamp()
        return f'{timestamp} {tweet} {location_tag}\n\nLocation details below ðŸ§µ'
    else:
        return None

def get_location_tweets(locations, appointments):
    tweets = []
    for id, appts in appointments.items():
        total = 0
        name = locations[id]['name']
        address = locations[id]['address']

        # Figure out earliest and latest day for this location
        start = None
        end = None
        for d, slots in appts.items():
            if not slots:
                continue

            day = datetime.strptime(d, '%Y-%m-%d')
            if not start:
                start = day
            else:
                start = min([start, day])

            if not end:
                end = day
            else:
                end = max([end, day])

        for slots in appts.values():
            total += len(slots)

        start = start.strftime('%m-%d-%Y')
        end = end.strftime('%m-%d-%Y')

        timestamp = get_timestamp()
        tweet = ''
        if start == end:
            if (total > 1):
                tweet += f'{timestamp} {total} of them on {start}'
            else:
                tweet += f'{timestamp} {total} on {start}'
        else:
            if (total > 1):
                tweet += f'{timestamp} {total} of them between {start} - {end}'
            else:
                # Should never happen
                tweet += f'{timestamp} {total} on {start} or {end}'

        tweet += f' when selecting ðŸ‘‡\n\n"{name}"\n{address}\n\nYou MUST confirm your appointment first!'
        tweets.append(tweet)

    return tweets

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--no-tweet', 
        help='Dont send out tweets',
        action='store_true',
        required=False,
    )

    parser.add_argument('--no-error', 
        help='Dont send error message DMs',
        action='store_true',
        required=False,
    )

    args = parser.parse_args()

    twitter_handler = TwitterHandler()

    while(True):
        for group in GEOCODES.keys():
            try:
                search_start = date.today()
                search_end = search_start + timedelta(days=8)
                locations, appts, total, appt_start, appt_end = get_group_appointments(group, search_start, search_end)

                if total:
                    start = appt_start.strftime('%m-%d-%Y')
                    end = appt_end.strftime('%m-%d-%Y')
                else:
                    start = search_start.strftime('%m-%d-%Y')
                    end = search_end.strftime('%m-%d-%Y')

                print_appointments(group, locations, appts, total, start, end, print_slots=True)
                print('Generating tweet:')
                print('-'* 10)
                tweet = get_summary_tweet(group, total, start, end)
                if tweet:
                    location_tweets = get_location_tweets(locations, appts)
                    tweets = [tweet, *location_tweets]
                    for t in tweets:
                        print(Fore.LIGHTMAGENTA_EX + t.replace('\n', '\n' + Fore.LIGHTMAGENTA_EX ) + Style.RESET_ALL)
                        print(f'Tweet was {len(t)} long')

                    if not args.no_tweet:
                        twitter_handler.tweet_thread(tweets)
                else:
                    print('<last tweet is still accurate. not tweeting>')
                print('-'* 10)
            except Exception:
                error_str = traceback.format_exc()
                if not args.no_error:
                    twitter_handler.dm(error_str)

                print(Fore.RED + error_str + Style.RESET_ALL)

        sleep = 60
        print(f'Sleeping {sleep} seconds...')
        time.sleep(sleep)

main()
